#include <cstdint>
#include<bits/stdc++.h>
#include<stdio.h>
#include<random>
#include<time.h>
#include<assert.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<netdb.h>
#include<arpa/inet.h>
#include<netinet/in.h>

//header for sha256
#include "picosha2.h"

// Google protobuf Header
#include <google/protobuf/message.h>
#include "choice.pb.h"
#define ROCK 0
#define PAPER 1
#define SCISSOR 2


using namespace google::protobuf;
using namespace std;





// Hash and a random number according to the Choice is generated. 
unsigned long long int generate_number_and_hash(int val,choice::Choice* choice_value)
{

	unsigned long long int temp=0;
	string hash_hex_str;
	// Runs until the choice related to the secific modulo value is obtained. 	
	while (1)
	{
		temp =rand();
		if (temp%3==val) break;
	}

	// Hash Function to generate SHA256 Hash	
	picosha2::hash256_hex_string(to_string(temp), hash_hex_str);
	
	//clear previous hash
	choice_value->clear_hash();
	//Set hash to the choice_value structure. 
	choice_value->set_hash(hash_hex_str);
	return temp;
}


// Utility function to find ceiling of r in arr[l..h] 
int findCeil(int arr[], int r, int l, int h) 
{ 
	int mid; 
	while (l < h) 
	{ 
		mid = l + ((h - l) >> 1); // Same as mid = (l+h)/2 
		(r > arr[mid]) ? (l = mid + 1) : (h = mid); 
	} 
	return (arr[l] >= r) ? l : -1; 
} 

// The main function that returns a random number from arr[] according to 
// distribution array defined by freq[]. n is size of arrays. 
int myRand(int arr[], int freq[]) 
{ 
	// Create and fill prefix array 
	int prefix[3], i; 
	prefix[0] = freq[0]; 
	for (i = 1; i < 3; ++i) 
		prefix[i] = prefix[i - 1] + freq[i]; 

	// prefix[n-1] is sum of all frequencies. Generate a random number 
	// with value from 1 to this sum 
	int r = (rand() % prefix[3 - 1]) + 1; 

	// Find index of ceiling of r in prefix arrat 
	int indexc = findCeil(prefix, r, 0, 3 - 1); 
	return arr[indexc]; 
} 

void SendData(choice::Choice& choice_value,int &socketDescriptor)
{
				string out;
				char sendBuffer[10000];
				choice_value.SerializeToString(&out);
				strncpy(sendBuffer, out.c_str(), sizeof(sendBuffer));
				send(socketDescriptor,sendBuffer,strlen(sendBuffer)+1,0);
}

void RecvData(choice::Choice& rchoice_value,int &socketDescriptor)
{
				char recvBuffer[10000];
				bzero(&recvBuffer,sizeof(recvBuffer));
				int bytes=0;
				bytes=recv(socketDescriptor,recvBuffer,sizeof(recvBuffer),0);
				assert (bytes>0);
				rchoice_value.ParseFromString(string(recvBuffer,0,bytes));
}



int Set_values(choice::Choice* choice_value,int arr[], int freq[],unsigned long long int* ChoiceEncrypted ) {
  cout << "Selecting Choice... "<<endl;
  int id;

  //finds Choice based on the Bias. 
  id= myRand(arr,freq);

  // The choice is given to the below function to generate hash and the number associated with it is returned.
  *ChoiceEncrypted = generate_number_and_hash(id,choice_value);
  return id;  
}

string ifTie(int &socketDescriptor,choice::Choice& choice_value,choice::Choice& rchoice_value)
{

			string hashc,hashd,vhashc;
			string out;
			char sendBuffer[10000],recvBuffer[10000];
			int bytes=0;
			unsigned long long int rndm=0,encC=0;
			//receive PLayer C hash of the random number
			RecvData(rchoice_value,socketDescriptor);
			hashc=rchoice_value.hash();
			rndm=rand();

			//compute hash
			picosha2::hash256_hex_string(to_string(rndm), hashd);
			choice_value.set_hash(hashd);
			sleep(1);

			//send hash of D
			SendData(choice_value,socketDescriptor);

			//receive random number generated by C
			RecvData(rchoice_value,socketDescriptor);
			encC=rchoice_value.choice();
			choice_value.set_choice(rndm);
			//Verify hash
			picosha2::hash256_hex_string(to_string(encC), vhashc);
			assert(hashc==vhashc);
			//serialize to Out string and send random number of C.
			sleep(1);
			SendData(choice_value,socketDescriptor);
			if (encC>rndm)  choice_value.set_whowin("C");	
			else choice_value.set_whowin("D");
			sleep(1);
			SendData(choice_value,socketDescriptor);//Send decision
			 
}

// Decision is taken based on the rules defined. Also the count of the winning choice is updated.
string decision(int cc, int cd,int freq[])
{

	if (cc==ROCK && cd ==ROCK) 
		{
			return "tie";
		}	

	if (cc==ROCK && cd ==PAPER) 
		{
			freq[PAPER]++;
			return "D";
		}

	if (cc==ROCK && cd ==SCISSOR) 
		{
			freq[ROCK]++;
			return "C";
		}

	if (cc==PAPER && cd ==PAPER) 
		{
			return "tie";
		}
	if (cc==PAPER && cd ==SCISSOR)
	{
		freq[SCISSOR]++;	
		return "D";	
	} 
	if (cc==PAPER && cd ==ROCK) 
		{
			freq[PAPER]++;
			return "C";
		}
	if (cc==SCISSOR && cd ==SCISSOR) 
	{
		return "tie";
	}
	if (cc==SCISSOR && cd ==PAPER)
	{
		freq[SCISSOR]++	;
		return "C";	
	} 
	if (cc==SCISSOR && cd ==ROCK)
	{
		freq[ROCK]++;
		return "D";
	} 
}



int main(int argc,char *argv[])
{

	srand (time(NULL));
	int ValueOf[] = {0, 1, 2};
	int freq[] = {1, 1, 1};
	choice::Choice choice_value;
	choice::Choice rchoice_value;	
	string output;
	string HashOfC,VerifyHashOfC;
	//char comm_addr_str[ INET_ADDRSTRLEN ];
	unsigned long long int ChoiceEncryptedC=0,ChoiceEncryptedD=0;
	int socketDescriptor;
	struct sockaddr_in serverAddress;
	char sendBuffer[10000],recvBuffer[10000];
	int bytes=0;
	bzero(&serverAddress,sizeof(serverAddress));
	const choice::Choice& temp = rchoice_value;

	serverAddress.sin_family=AF_INET;
	//if (argv[1]=="localhost") 
	// serverAddress.sin_addr.s_addr=htonl(INADDR_ANY);
	inet_pton(AF_INET, argv[1], &serverAddress.sin_addr);
	//serverAddress.sin_addr.s_addr=inet_addr((argv[1]));
	serverAddress.sin_port=htons(atoi(argv[2]));

/*Creating a socket, assigning IP address and port number for that socket*/
	socketDescriptor=socket(AF_INET,SOCK_STREAM,0);

/*Connect establishes connection with the server using server IP address*/
	if(connect(socketDescriptor,(struct sockaddr*)&serverAddress,sizeof(serverAddress))<0) printf("connection error\n");;
	



	while(1)
	{

		bzero(&sendBuffer,sizeof(sendBuffer));
		bzero(&recvBuffer,sizeof(recvBuffer));

	/*Chooses Choice from Rock Paper Scissor and returns it. Also the number associated with the choice is generated.
	 The hash of the number is automatically set to the choice_value structure. 
	*/
		int ChoiceOfD=Set_values(&choice_value,ValueOf,freq,&ChoiceEncryptedD);
		sleep(1);
		//Status of C is received. If Draw then goes to iftie function.
		RecvData(rchoice_value,socketDescriptor);
		if (temp.status()=="Draw") 
		{
			ifTie(socketDescriptor,choice_value,rchoice_value);

		}

		//Write Ready to choice_value structure and send it to C
		choice_value.set_status("Ready");
		SendData(choice_value,socketDescriptor);	
		sleep(1);	
		if (temp.status()=="Ready") 
		{
			//receive hash from Player C
			RecvData(rchoice_value,socketDescriptor);
			HashOfC=temp.hash();
			

			sleep(1);

			//Send hash 
			SendData(choice_value,socketDescriptor);
			
			sleep(1);

			//Receive Random number associated with the choice.
			RecvData(rchoice_value,socketDescriptor);
			ChoiceEncryptedC=temp.choice();

			//Number of D associated with the choice is written to the choice_value structure.
			choice_value.set_choice(ChoiceEncryptedD);
			sleep(1);
			//Structure is serialized to string output and sent to C.
			SendData(choice_value,socketDescriptor);

			// hash of the C is verified to the Encrypted C to check if the value was not changed.
			picosha2::hash256_hex_string(to_string(ChoiceEncryptedC), VerifyHashOfC);
			assert(VerifyHashOfC==HashOfC);


			//The Encrypted choice is broken down to the actual choice using modulo operaiton.	
			int ChoiceOfC=ChoiceEncryptedC%3;

			cout << "Choice from C: " << ChoiceOfC << endl;

			//Decision based on the choice obtained. It is then written to the choice_value structure 
			choice_value.set_whowin(decision(ChoiceOfC,ChoiceOfD,freq));

			//structure is serialized to output string and Decision is sent.
			SendData(choice_value,socketDescriptor);
			

			// decision from C is received.
			RecvData(rchoice_value,socketDescriptor);
			assert(rchoice_value.whowin()==choice_value.whowin());
			
			//Signal is given to update the database.
			choice_value.set_status("Update Database");
			SendData(choice_value,socketDescriptor);


		}	

	}

	return 0;
}